#!/usr/bin/env ruby

require 'json'
require 'pp'
require 'open3'
require 'yaml'
require 'digest'

module Ow
  CONTAINER_NAME = "kureikain/opsworks:0.4"

  class Generator
    def instance
      puts "> Layer ?"
      layer = STDIN.gets.chomp
      puts "> name"
      name = STDIN.gets.chomp
      puts "> private ip"
      private_ip = STDIN.gets.chomp
      puts "> Will generate random public ip"

      puts "> Update our opswork file"
      instance = Instance.new(layer, name, {
        'private_ip' => private_ip
      })
      
    end
  end

  class Command
    attr_reader :insance

    def initialize(instance)
      @instance = instance
    end
  end


  class Instance
    attr_reader :name, :layer

    def to_hash
      @hash.merge({'name' => name})
    end

    def initialize(layer, name, hash)
      @layer = layer
      @name = name
      @hash = hash
      inspect
    end

    def inspect
      o, s = Open3.capture2("docker inspect #{container_name}", :stdin_data => "")
      begin
        @json = JSON.parse(o)
        @json = @json.first
      rescue => e
        puts e
      end
    end

    def [](idx)
      if @hash[idx].nil?
        nil
      else
        @hash[idx] || @hash[idx.to_s]
      end
    end

    # Destroy container
    def destroy
      cmd = "docker stop #{container_name}"
      o, s = Open3.capture2(cmd, :stdin_data => "")
      puts "Stop #{o}"
      cmd = "docker rm #{container_name}"
      o, s = Open3.capture2(cmd, :stdin_data => "")
      puts "Destory #{o}"
    end

    def container_ip
      @json["NetworkSettings"]["IPAddress"]
    end

    def run(opt)
      if @json.nil? || @json["NetworkSettings"].nil?
        cmd = "docker run --name #{container_name} -h #{name} -d -v #{Dir.pwd}:/opt/opsworks #{CONTAINER_NAME}"
        puts cmd
        o, s = Open3.capture2(cmd, :stdin_data => "")
        inspect
      end
    end

    def container_name
      "#{@name}-#{@hash['private_ip']}"
    end

    # Generate a prefix for this folder
    def prefix
      @md5 ||= Digest::MD5.new
      @md5.update Dir.pwd
    end
  end

  class Json
    attr_reader :hash, :json_file, :opsworks_json

    def initialize(json_file)
      @json_file = json_file
      @opsworks_json = JSON.parse(File.read(json_file))
    end

    def layers
      opsworks_json["opsworks"]["layers"]
    end

    def merge_current_instance!(node)
      opsworks_json["opsworks"]["instance"].merge!(node.to_hash)

      puts JSON.generate(opsworks_json, object_nl: "\n", array_nl: "\n")
      save!
    end

    def flush
      save!
    end

    def add(element)
      case element
      when Instance
        add_instance(element)
      end
    end

    def add_instance(instance)
      opsworks_json["opsworks"]["layers"][instance.layer][instance.name] = instance.to_hash
    end

    private
    def save!
      File.open(json_file, 'w') do |f|
        f.write(JSON.pretty_generate(opsworks_json, object_nl: "\n", array_nl: "\n"))
      end
    end
  end

  class Runner

    attr_reader :ssh, :json_file, :opsworks_json
    attr_reader :args
    attr_reader :rc

    class << self
      def dispatch(args)
        ow = Runner.new args
        case args[0]
        when 'destroy'
          ow.destroy
        when 'json', 'getjson'
          ow.get_json
        when 'init'
          ow.init
        when 'exec'
          ow.exec
        when 'current', 'promote'
          ow.promote_current args[1]
        when 'test'
          ow.test
        when 'ls'
          ow.list
        when 'generate'
          ow.generate
        else
          help
        end
        ow
      end

      def help
        puts <<-EOF
        destroy: destroy container
        init: init container
        current: set current to this node
        test: run test
        ls: list instance in JSON file
        EOF
      end
    end

    def initialize(args)
      @args = args
      @rc = 0
      @ssh = {
        user: ENV['OW_SSH_USER'],
        host: ENV['OW_SSH_HOST'],
        key:  ENV['OW_SSH_KEY'],
      }
      @json_file = ENV['OW_JSON'] || 'opsworks.json'
      parse
    end

    def parse
      begin
        @opsworks_json = Json.new @json_file

        @instances = @opsworks_json.layers
          .select {|name, l| !l["instances"].nil? }
          .map do |name, layer|
          layer["instances"].map do |host, instance|
            Instance.new name, host, instance
          end
        end.flatten
      rescue  => e
        puts "Cannot parse json. #{e}"
        exit 1
      end
    end

    # Spawn container
    def spawn_container
      @instances.each do |i|
        puts "> Create container for: #{i['private_ip']}"
        i.run({})
        puts "> Got IP: #{i.container_ip}"
      end
      run_on('all', silent: true) do
        inject_hostname
      end
    end

    # Filter containers base on our condition
    # Logic:
    # * -> all
    # all -> all
    # first -> first one only
    # last -> last on
    # rnd -> random
    # cluster1 -> a particular host
    # cluster1,cluster2 -> multiple hosts
    def filter(hosts, instance)
      if hosts == '*' || hosts == 'all'
        return true
      end

      if instance.name == hosts 
        return true
      end

      if hosts.include?(',')
        h = hosts.split(',').map(&:strip)
        return h.include?(instance.name)
      end
    end

    # Run command on container
    def run_on(name, opts = {})
      @instances.select do |i|
        filter(name, i)
      end.each do |i|
        build_cmd = yield
        cmd = "docker exec #{i.container_name} /bin/bash -c \"#{build_cmd}\""
        if opts[:silent]
          Open3.capture2(cmd, :stdin_data => "")
        else
          o, s = Open3.capture2(cmd, :stdin_data => "")
          puts "\n================\nRun on #{i.name}:\n#{build_cmd}\n#{o}\n================\nOutput\n"
        end
      end
    end

    # Inject hostname
    def inject_hostname
      hosts = @instances.map do |i|
        "#{i.container_ip} #{i.name}"
      end.join('\n')
      "echo -e '#{hosts}' >> /etc/hosts"
    end

    # Fix IP address
    def match_private_ip_to_container
      @instances.map do |i|
        "sed -ie \"s/#{i['private_ip'].gsub('.', '\.')}/#{i.container_ip}/g\" /ops/opsworks.json"
      end.join(";")
    end

    # Update current instance
    def promote_current(name)
      node = @instances.select { |i| name == i.name }
      if node.empty?
        puts "Cannot find node #{name}"
      else
        node = node.first
        @opsworks_json.merge_current_instance!(node)
      end
    end

    # Generator
    def generate
      type = args[1]
      case type
      when 'host'
        Ow::Generator.new.instance
      end
    end

    # Run test
    def test
      # Map container to host
      host = args[1]
      if host.nil? || host == ''
        @rc = 1
        puts "Plese specify hosts"
        return
      end
      spawn_container
      s = match_private_ip_to_container
      puts "> Update Host IP to container IP using sed.\n#{s}\n=====================\n"
      run_on host do
        %Q{
        mkdir -p /ops/cookbooks; cp /opt/opsworks/opsworks.json /ops;#{s};
        cp /opt/opsworks/Berksfile /ops; cd /ops; rsync -rap /opt/opsworks/ cookbooks/;
        rsync -rap /opt/opsworks-cookbooks/ cookbooks/;
        export LC_CTYPE=en_US.UTF-8; berks install; berks vendor a;
        cp -rf a/* cookbooks/;
        chef-client --local-mode  -o 'recipe[#{args[2]}]' -j /ops/opsworks.json -l info 2>&1;
        }
      end
    end

    # Destroy
    def destroy
      @instances.each(&:destroy)
    end

    # List nodes
    def list
      @instances.each { |i| puts "=============\n#{i.name}\n>#{i.to_hash}\n\n" }
    end

    # Get json data
    def get_json
      cmd = %W{ssh -i
              #{@ssh[:key]}
              #{@ssh[:user]}@#{@ssh[:host]}
      }.join(" ")
      o, s = Open3.capture2(cmd, :stdin_data => "")
      File.open('opsworks.json') { |f| f.write o }.close
    end

    def init
      spawn_container
      File.open('ow.yml', 'w') do |f|
        f.write <<-EOF
---
SSH:
  User: ubuntu
  Host:
  Key:
        EOF
      end
      puts "> You can edit content of ow.yml file"
    end
  end
end

exit(Ow::Runner.dispatch(ARGV).rc)
